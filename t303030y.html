<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Random Chat Pro - Next Generation Video & Text Chat</title>
    
    <!-- Improved CDN loading with SRI for security -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css" integrity="sha512-UJfAaOlIRtdR+0P6C3KUoTDAxVTuy3lnSXLyLKlHYJlcSU8Juge/mjeaxDNMlw9LgeIotgz5FP8eUQPhX1q10A==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js" integrity="sha512-NiWqa2rceHnN3Z5j6mSAvbwwg3tiwVNxiAQaaSMSXnRRDh5C2mk/+sKQRw8qjV1vN4nf8iK2a0b048PnHbyx+Q==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    
    <!-- Updated Firebase SDK to latest version -->
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-analytics-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-auth-compat.js"></script>
    
    <!-- New additions -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css" />
    <link rel="manifest" href="/manifest.json">
    <meta name="theme-color" content="#ff5722">
    
    <style>
        /* Modern CSS variables for theming */
        :root {
            --primary-color: #ff5722;
            --primary-dark: #e64a19;
            --secondary-color: #2196f3;
            --error-color: #f44336;
            --success-color: #4caf50;
            --warning-color: #ff9800;
            --dark-text: #333;
            --light-text: #fff;
            --bg-color: #f5f5f5;
            --card-bg: #fff;
            --border-color: #e0e0e0;
            --shadow: 0 2px 10px rgba(0,0,0,0.1);
            --transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        }
        
        /* Modern reset and base styles */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--dark-text);
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        /* Improved header with gradient */
        header {
            background: linear-gradient(135deg, var(--primary-color), var(--primary-dark));
            box-shadow: var(--shadow);
            padding: 15px 0;
            margin-bottom: 30px;
            color: var(--light-text);
        }
        
        .logo {
            font-size: 28px;
            font-weight: 700;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        
        .logo i {
            font-size: 32px;
        }
        
        /* Enhanced selection screen */
        .selection-screen {
            background-color: var(--card-bg);
            border-radius: 12px;
            box-shadow: var(--shadow);
            padding: 40px;
            text-align: center;
            margin-top: 30px;
            transition: var(--transition);
        }
        
        .selection-title {
            font-size: 32px;
            margin-bottom: 40px;
            color: var(--dark-text);
            font-weight: 600;
        }
        
        .options-container {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .chat-option {
            width: 250px;
            padding: 30px 20px;
            border-radius: 12px;
            cursor: pointer;
            transition: var(--transition);
            background-color: var(--card-bg);
            border: 2px solid transparent;
            position: relative;
            overflow: hidden;
        }
        
        .chat-option::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 5px;
            background-color: var(--primary-color);
            transform: scaleX(0);
            transition: var(--transition);
        }
        
        .chat-option:hover {
            transform: translateY(-10px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
        }
        
        .chat-option:hover::before {
            transform: scaleX(1);
        }
        
        .chat-option.selected {
            border-color: var(--primary-color);
            background-color: rgba(255, 87, 34, 0.05);
        }
        
        .chat-option.selected::before {
            transform: scaleX(1);
        }
        
        .chat-option i {
            font-size: 60px;
            margin-bottom: 20px;
            display: block;
            color: var(--primary-color);
            transition: var(--transition);
        }
        
        .chat-option:hover i {
            transform: scale(1.1);
        }
        
        .chat-option h3 {
            margin: 0 0 10px;
            font-size: 22px;
            font-weight: 600;
        }
        
        .chat-option p {
            color: #666;
            font-size: 16px;
        }
        
        /* Modern button styles */
        .btn {
            border-radius: 50px;
            padding: 14px 36px;
            font-size: 18px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: var(--transition);
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border: none;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .btn-primary {
            background-color: var(--primary-color);
            color: white;
        }
        
        .btn-primary:hover {
            background-color: var(--primary-dark);
        }
        
        .btn-secondary {
            background-color: var(--secondary-color);
            color: white;
        }
        
        .btn-danger {
            background-color: var(--error-color);
            color: white;
        }
        
        .btn-warning {
            background-color: var(--warning-color);
            color: white;
        }
        
        .btn-outline {
            background-color: transparent;
            border: 2px solid var(--primary-color);
            color: var(--primary-color);
        }
        
        .btn-outline:hover {
            background-color: var(--primary-color);
            color: white;
        }
        
        /* Enhanced chat screens */
        .chat-screen {
            display: none;
            background-color: var(--card-bg);
            border-radius: 12px;
            box-shadow: var(--shadow);
            overflow: hidden;
            height: calc(100vh - 200px);
            max-height: 800px;
            position: relative;
        }
        
        .status-bar {
            padding: 12px 20px;
            background-color: var(--primary-color);
            color: white;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .timer {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .timer i {
            font-size: 18px;
        }
        
        /* Modern video container */
        .video-container {
            position: relative;
            width: 100%;
            height: calc(100% - 120px);
            background-color: #000;
            overflow: hidden;
        }
        
        .remote-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
            background-color: #111;
        }
        
        .local-video {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 25%;
            max-width: 200px;
            border: 2px solid #fff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            transition: var(--transition);
            z-index: 10;
        }
        
        .local-video:hover {
            transform: scale(1.05);
        }
        
        /* Video controls */
        .video-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 10;
        }
        
        .control-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: var(--transition);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            border: none;
            color: white;
        }
        
        .control-btn i {
            font-size: 24px;
        }
        
        .control-btn:hover {
            transform: scale(1.1);
        }
        
        .mute-btn {
            background-color: rgba(255,255,255,0.2);
        }
        
        .mute-btn.active {
            background-color: var(--error-color);
        }
        
        .video-off-btn {
            background-color: rgba(255,255,255,0.2);
        }
        
        .video-off-btn.active {
            background-color: var(--error-color);
        }
        
        /* Enhanced text chat */
        .chat-container {
            display: flex;
            flex-direction: column;
            height: calc(100% - 120px);
            border: 1px solid var(--border-color);
            border-radius: 0;
            overflow: hidden;
        }
        
        .chat-messages {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            background-color: #f9f9f9;
            scroll-behavior: smooth;
        }
        
        .message {
            margin-bottom: 15px;
            padding: 12px 16px;
            border-radius: 18px;
            max-width: 80%;
            word-wrap: break-word;
            position: relative;
            opacity: 0;
            transform: translateY(10px);
            animation: fadeInUp 0.3s forwards;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        
        @keyframes fadeInUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .received {
            background-color: var(--card-bg);
            align-self: flex-start;
            border-bottom-left-radius: 4px;
            border: 1px solid var(--border-color);
        }
        
        .sent {
            background-color: var(--primary-color);
            color: white;
            align-self: flex-end;
            border-bottom-right-radius: 4px;
        }
        
        .message-time {
            display: block;
            font-size: 11px;
            opacity: 0.7;
            margin-top: 4px;
            text-align: right;
        }
        
        .chat-input-container {
            display: flex;
            padding: 15px;
            background-color: var(--card-bg);
            border-top: 1px solid var(--border-color);
            gap: 10px;
        }
        
        .chat-input {
            flex: 1;
            padding: 12px 20px;
            border: 1px solid var(--border-color);
            border-radius: 50px;
            outline: none;
            font-size: 16px;
            transition: var(--transition);
        }
        
        .chat-input:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(255, 87, 34, 0.2);
        }
        
        .send-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: var(--transition);
            background-color: var(--primary-color);
            color: white;
            border: none;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        .send-btn:hover {
            background-color: var(--primary-dark);
            transform: scale(1.05);
        }
        
        .send-btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        .chat-controls {
            display: flex;
            justify-content: space-between;
            padding: 15px;
            background-color: var(--card-bg);
            border-top: 1px solid var(--border-color);
            gap: 10px;
        }
        
        /* Loading screen improvements */
        .loading-screen {
            display: none;
            text-align: center;
            padding: 50px;
            background-color: var(--card-bg);
            border-radius: 12px;
            box-shadow: var(--shadow);
            max-width: 600px;
            margin: 50px auto;
        }
        
        .loading-title {
            font-size: 28px;
            margin-bottom: 20px;
            color: var(--dark-text);
            font-weight: 600;
        }
        
        .loading-spinner {
            margin: 40px auto;
            width: 80px;
            height: 80px;
            position: relative;
        }
        
        .loading-spinner .circle {
            position: absolute;
            width: 100%;
            height: 100%;
            border: 8px solid transparent;
            border-top-color: var(--primary-color);
            border-radius: 50%;
            animation: spin 1.5s linear infinite;
        }
        
        .loading-spinner .circle:nth-child(2) {
            border-top-color: var(--secondary-color);
            animation-delay: 0.3s;
            width: 70%;
            height: 70%;
            top: 15%;
            left: 15%;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .status-message {
            font-size: 18px;
            margin-bottom: 30px;
            color: #666;
        }
        
        /* Connection quality indicator */
        .connection-quality {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 14px;
        }
        
        .quality-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: var(--success-color);
        }
        
        .quality-indicator.fair {
            background-color: var(--warning-color);
        }
        
        .quality-indicator.poor {
            background-color: var(--error-color);
        }
        
        /* Typing indicator */
        .typing-indicator {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-left: 10px;
            font-size: 14px;
            color: #666;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .typing-indicator.active {
            opacity: 1;
        }
        
        .typing-dots {
            display: flex;
            gap: 3px;
        }
        
        .typing-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background-color: #666;
            animation: typingAnimation 1.4s infinite both;
        }
        
        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }
        
        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }
        
        @keyframes typingAnimation {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1); }
        }
        
        /* Enhanced modals */
        .modal {
            border-radius: 12px;
            overflow: hidden;
            max-width: 500px;
        }
        
        .modal-content {
            padding: 30px;
        }
        
        .modal-content h4 {
            font-size: 24px;
            margin-bottom: 20px;
            color: var(--dark-text);
        }
        
        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            padding: 20px;
            border-top: 1px solid var(--border-color);
        }
        
        /* Notification badge */
        .notification-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background-color: var(--error-color);
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
        }
        
        /* Empty state */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            text-align: center;
            padding: 30px;
            color: #666;
        }
        
        .empty-state i {
            font-size: 60px;
            margin-bottom: 20px;
            color: #ccc;
        }
        
        /* Responsive design improvements */
        @media (max-width: 992px) {
            .container {
                padding: 15px;
            }
            
            .selection-screen {
                padding: 30px 20px;
            }
            
            .chat-option {
                width: 200px;
                padding: 25px 15px;
            }
            
            .local-video {
                width: 30%;
            }
        }
        
        @media (max-width: 768px) {
            .selection-title {
                font-size: 28px;
                margin-bottom: 30px;
            }
            
            .options-container {
                gap: 20px;
            }
            
            .chat-option {
                width: 100%;
                max-width: 300px;
            }
            
            .chat-screen {
                height: calc(100vh - 150px);
            }
            
            .video-container {
                height: calc(100% - 100px);
            }
            
            .local-video {
                width: 35%;
                max-width: 150px;
            }
        }
        
        @media (max-width: 480px) {
            .selection-screen {
                padding: 20px 15px;
                margin-top: 20px;
            }
            
            .selection-title {
                font-size: 24px;
                margin-bottom: 25px;
            }
            
            .chat-option i {
                font-size: 50px;
                margin-bottom: 15px;
            }
            
            .chat-option h3 {
                font-size: 20px;
            }
            
            .btn {
                padding: 12px 24px;
                font-size: 16px;
            }
            
            .local-video {
                width: 40%;
                bottom: 10px;
                right: 10px;
            }
            
            .status-bar {
                flex-direction: column;
                gap: 5px;
                padding: 10px;
                text-align: center;
            }
            
            .chat-controls {
                flex-wrap: wrap;
                justify-content: center;
            }
            
            .modal-content {
                padding: 20px;
            }
        }
        
        /* Dark mode support */
        @media (prefers-color-scheme: dark) {
            :root {
                --dark-text: #f5f5f5;
                --light-text: #f5f5f5;
                --bg-color: #121212;
                --card-bg: #1e1e1e;
                --border-color: #333;
            }
            
            .chat-messages {
                background-color: #121212;
            }
            
            .received {
                background-color: #2d2d2d;
                border-color: #333;
            }
            
            .chat-input {
                background-color: #2d2d2d;
                color: white;
            }
            
            .empty-state i {
                color: #444;
            }
        }
        
        /* Accessibility improvements */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }
        
        /* Focus styles for accessibility */
        button:focus, input:focus, textarea:focus {
            outline: 2px solid var(--primary-color);
            outline-offset: 2px;
        }
        
        /* Animation for new messages */
        @keyframes newMessage {
            0% { transform: scale(0.95); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .new-message {
            animation: newMessage 0.3s ease;
        }
    </style>
</head>
<body>
    <!-- Header with improved navigation -->
    <header>
        <div class="container">
            <div class="logo">
                <i class="material-icons">chat_bubble_outline</i>
                <span>Random Chat Pro</span>
            </div>
        </div>
    </header>
    
    <!-- Main Content -->
    <div class="container">
        <!-- Selection Screen with enhanced options -->
        <div id="selection-screen" class="selection-screen animate__animated animate__fadeIn">
            <h2 class="selection-title">Choose Your Chat Experience</h2>
            <div class="options-container">
                <div id="video-option" class="chat-option" tabindex="0" role="button" aria-label="Video chat option">
                    <i class="material-icons">videocam</i>
                    <h3>Video Chat</h3>
                    <p>Face-to-face conversations with real people</p>
                    <div class="sr-only">Select for video chat with webcam and microphone</div>
                </div>
                <div id="text-option" class="chat-option" tabindex="0" role="button" aria-label="Text chat option">
                    <i class="material-icons">chat</i>
                    <h3>Text Chat</h3>
                    <p>Private text conversations with strangers</p>
                    <div class="sr-only">Select for text-only chat experience</div>
                </div>
            </div>
            <button id="start-btn" class="btn btn-primary waves-effect waves-light">
                <i class="material-icons left">play_arrow</i>
                START CHATTING
            </button>
            
            <!-- New features list -->
            <div class="features-list" style="margin-top: 40px; text-align: left; max-width: 800px; margin-left: auto; margin-right: auto;">
                <h4 style="text-align: center; margin-bottom: 20px; color: var(--primary-color);">Why Choose Our Platform?</h4>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px;">
                    <div style="display: flex; align-items: flex-start; gap: 10px;">
                        <i class="material-icons" style="color: var(--primary-color);">security</i>
                        <div>
                            <h5 style="margin-bottom: 5px;">Safe & Secure</h5>
                            <p style="color: #666; font-size: 14px;">End-to-end encrypted chats and anonymous connections</p>
                        </div>
                    </div>
                    <div style="display: flex; align-items: flex-start; gap: 10px;">
                        <i class="material-icons" style="color: var(--primary-color);">flash_on</i>
                        <div>
                            <h5 style="margin-bottom: 5px;">Lightning Fast</h5>
                            <p style="color: #666; font-size: 14px;">Instant connections with minimal waiting time</p>
                        </div>
                    </div>
                    <div style="display: flex; align-items: flex-start; gap: 10px;">
                        <i class="material-icons" style="color: var(--primary-color);">group</i>
                        <div>
                            <h5 style="margin-bottom: 5px;">Global Community</h5>
                            <p style="color: #666; font-size: 14px;">Connect with people from around the world</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Enhanced Loading Screen -->
        <div id="loading-screen" class="loading-screen">
            <h3 class="loading-title">Finding Your Perfect Match...</h3>
            <div class="loading-spinner">
                <div class="circle"></div>
                <div class="circle"></div>
            </div>
            <p id="status-message" class="status-message">Initializing connection...</p>
            <div id="connection-quality" class="connection-quality" style="display: none;">
                <span>Connection Quality:</span>
                <div id="quality-indicator" class="quality-indicator"></div>
            </div>
            <button id="cancel-search-btn" class="btn btn-outline waves-effect waves-light">
                <i class="material-icons left">close</i>
                CANCEL SEARCH
            </button>
        </div>
        
        <!-- Video Chat Screen with improved controls -->
        <div id="video-chat-screen" class="chat-screen">
            <div class="status-bar">
                <div>
                    <span id="video-status">Connecting...</span>
                    <span id="video-typing-indicator" class="typing-indicator">
                        <span>Partner is typing</span>
                        <div class="typing-dots">
                            <div class="typing-dot"></div>
                            <div class="typing-dot"></div>
                            <div class="typing-dot"></div>
                        </div>
                    </span>
                </div>
                <div class="timer">
                    <i class="material-icons">access_time</i>
                    <span id="video-timer">00:00</span>
                </div>
            </div>
            <div class="video-container">
                <video id="remote-video" class="remote-video" autoplay playsinline></video>
                <video id="local-video" class="local-video" autoplay playsinline muted></video>
                
                <div class="video-controls">
                    <button id="mute-audio-btn" class="control-btn mute-btn" aria-label="Mute audio">
                        <i class="material-icons">mic</i>
                    </button>
                    <button id="mute-video-btn" class="control-btn video-off-btn" aria-label="Turn off video">
                        <i class="material-icons">videocam</i>
                    </button>
                </div>
            </div>
            <div class="chat-controls">
                <button id="video-skip-btn" class="btn btn-warning waves-effect">
                    <i class="material-icons left">skip_next</i> Skip
                </button>
                <button id="video-report-btn" class="btn btn-danger waves-effect">
                    <i class="material-icons left">report</i> Report
                </button>
                <button id="video-switch-btn" class="btn btn-secondary waves-effect">
                    <i class="material-icons left">swap_horiz</i> Switch to Text
                </button>
            </div>
        </div>
        
        <!-- Enhanced Text Chat Screen -->
        <div id="text-chat-screen" class="chat-screen">
            <div class="status-bar">
                <div>
                    <span id="text-status">Connected</span>
                    <span id="text-typing-indicator" class="typing-indicator">
                        <span>Partner is typing</span>
                        <div class="typing-dots">
                            <div class="typing-dot"></div>
                            <div class="typing-dot"></div>
                            <div class="typing-dot"></div>
                        </div>
                    </span>
                </div>
                <div class="timer">
                    <i class="material-icons">access_time</i>
                    <span id="text-timer">00:00</span>
                </div>
            </div>
            <div class="chat-container">
                <div id="text-messages" class="chat-messages">
                    <div class="empty-state">
                        <i class="material-icons">forum</i>
                        <h4>Start a conversation!</h4>
                        <p>Send your first message to begin chatting with your partner.</p>
                    </div>
                </div>
                <div class="chat-input-container">
                    <input id="text-input" type="text" class="chat-input" placeholder="Type your message..." aria-label="Type your message">
                    <button id="text-send-btn" class="send-btn" aria-label="Send message">
                        <i class="material-icons">send</i>
                    </button>
                </div>
            </div>
            <div class="chat-controls">
                <button id="text-skip-btn" class="btn btn-warning waves-effect">
                    <i class="material-icons left">skip_next</i> Skip
                </button>
                <button id="text-report-btn" class="btn btn-danger waves-effect">
                    <i class="material-icons left">report</i> Report
                </button>
                <button id="text-switch-btn" class="btn btn-secondary waves-effect">
                    <i class="material-icons left">swap_horiz</i> Switch to Video
                </button>
            </div>
        </div>
    </div>
    
    <!-- Enhanced Modals -->
    <div id="report-modal" class="modal">
        <div class="modal-content">
            <h4>Report User</h4>
            <p>Help us keep the community safe by reporting inappropriate behavior.</p>
            <form action="#">
                <div style="display: grid; grid-template-columns: 1fr; gap: 15px; margin-top: 20px;">
                    <label class="radio-option">
                        <input name="report-reason" type="radio" value="spam" checked />
                        <span>Spam or advertising</span>
                    </label>
                    <label class="radio-option">
                        <input name="report-reason" type="radio" value="abuse" />
                        <span>Abusive or harmful behavior</span>
                    </label>
                    <label class="radio-option">
                        <input name="report-reason" type="radio" value="nudity" />
                        <span>Inappropriate content</span>
                    </label>
                    <label class="radio-option">
                        <input name="report-reason" type="radio" value="underage" />
                        <span>Underage user</span>
                    </label>
                    <label class="radio-option">
                        <input name="report-reason" type="radio" value="other" />
                        <span>Other issue</span>
                    </label>
                </div>
                <div class="input-field" style="margin-top: 20px;">
                    <textarea id="report-notes" class="materialize-textarea" placeholder="Please provide additional details (optional)"></textarea>
                    <label for="report-notes">Additional information</label>
                </div>
            </form>
        </div>
        <div class="modal-footer">
            <a href="#!" class="modal-close btn btn-outline">Cancel</a>
            <a id="submit-report-btn" class="btn btn-danger">Submit Report</a>
        </div>
    </div>
    
    <div id="disconnected-modal" class="modal">
        <div class="modal-content">
            <h4>Connection Lost</h4>
            <p>Your chat partner has disconnected. We can help you find someone new to chat with.</p>
        </div>
        <div class="modal-footer">
            <a href="#!" class="modal-close btn btn-outline">Maybe Later</a>
            <a id="find-new-btn" class="btn btn-primary">Find New Partner</a>
        </div>
    </div>
    
    <div id="permission-modal" class="modal">
        <div class="modal-content">
            <h4>Permission Required</h4>
            <p id="permission-message">To use video chat, please allow access to your camera and microphone.</p>
        </div>
        <div class="modal-footer">
            <a href="#!" class="modal-close btn btn-outline">Cancel</a>
            <a id="retry-permission-btn" class="btn btn-primary">Try Again</a>
        </div>
    </div>

    <script>
        // Enhanced Firebase Configuration with error handling
        const firebaseConfig = {
            apiKey: "AIzaSyDUpOtYEp0vvpvVglJWTt_PzwabklOOPKI",
            authDomain: "turkify-messenger.firebaseapp.com",
            projectId: "turkify-messenger",
            storageBucket: "turkify-messenger.firebasestorage.app",
            messagingSenderId: "881925084444",
            appId: "1:881925084444:web:21afeeb4b1127dbfab16d9",
            measurementId: "G-8V22W8PS30"
        };
        
        // Initialize Firebase with error handling
        try {
            firebase.initializeApp(firebaseConfig);
            const db = firebase.firestore();
            const auth = firebase.auth();
            const analytics = firebase.analytics();
            
            // Enable Firestore offline persistence
            db.enablePersistence()
                .catch(err => {
                    console.error('Firestore offline persistence error:', err);
                });
        } catch (error) {
            console.error('Firebase initialization error:', error);
            showError('Failed to initialize the chat service. Please refresh the page.');
        }
        
        // Global variables with enhanced state management
        const appState = {
            currentUser: null,
            chatMode: null, // 'video' or 'text'
            chatRoomId: null,
            chatPartnerId: null,
            localStream: null,
            peerConnection: null,
            chatStartTime: null,
            timerInterval: null,
            isSearching: false,
            isTyping: false,
            partnerTyping: false,
            typingTimeout: null,
            connectionQuality: 'good', // 'good', 'fair', 'poor'
            mediaState: {
                audioEnabled: true,
                videoEnabled: true
            }
        };
        
        // Enhanced ICE servers configuration with fallbacks
        const iceServers = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                { urls: 'stun:stun3.l.google.com:19302' },
                { urls: 'stun:stun4.l.google.com:19302' },
                {
                    urls: 
'turn:eu-turn4.xirsys.com:3478
transport=udp',
                    username: 'BI8akHbp76XCAiucNwvXIfbU8TBXmhVgw7MZ3WJfqOv6wBlzymh1U3USfGLI2gTbAAAAAGgxLPxvc2FtYTIxMg==',
                    credential: 'b2442f60-3845-11f0-a2da-0242ac140004'
                }
            ],
            iceCandidatePoolSize: 10
        };
        
        // Enhanced offensive words filter with more comprehensive list
        const offensiveWords = [
            'fuck', 'shit', 'asshole', 'bitch', 'cunt', 'nigger', 'whore', 'slut',
            'fag', 'retard', 'kys', 'kill yourself', 'rape', 'pedo', 'nazi', 'hitler'
        ];
        
        // DOM Elements with better organization
        const elements = {
            // Selection screen
            selectionScreen: document.getElementById('selection-screen'),
            loadingScreen: document.getElementById('loading-screen'),
            videoChatScreen: document.getElementById('video-chat-screen'),
            textChatScreen: document.getElementById('text-chat-screen'),
            startBtn: document.getElementById('start-btn'),
            videoOption: document.getElementById('video-option'),
            textOption: document.getElementById('text-option'),
            cancelSearchBtn: document.getElementById('cancel-search-btn'),
            statusMessage: document.getElementById('status-message'),
            connectionQuality: document.getElementById('connection-quality'),
            qualityIndicator: document.getElementById('quality-indicator'),
            
            // Video chat elements
            remoteVideo: document.getElementById('remote-video'),
            localVideo: document.getElementById('local-video'),
            videoStatus: document.getElementById('video-status'),
            videoTimer: document.getElementById('video-timer'),
            videoSkipBtn: document.getElementById('video-skip-btn'),
            videoReportBtn: document.getElementById('video-report-btn'),
            videoSwitchBtn: document.getElementById('video-switch-btn'),
            muteAudioBtn: document.getElementById('mute-audio-btn'),
            muteVideoBtn: document.getElementById('mute-video-btn'),
            videoTypingIndicator: document.getElementById('video-typing-indicator'),
            
            // Text chat elements
            textStatus: document.getElementById('text-status'),
            textTimer: document.getElementById('text-timer'),
            textMessages: document.getElementById('text-messages'),
            textInput: document.getElementById('text-input'),
            textSendBtn: document.getElementById('text-send-btn'),
            textSkipBtn: document.getElementById('text-skip-btn'),
            textReportBtn: document.getElementById('text-report-btn'),
            textSwitchBtn: document.getElementById('text-switch-btn'),
            textTypingIndicator: document.getElementById('text-typing-indicator'),
            
            // Modal elements
            submitReportBtn: document.getElementById('submit-report-btn'),
            findNewBtn: document.getElementById('find-new-btn'),
            retryPermissionBtn: document.getElementById('retry-permission-btn'),
            reportModal: document.getElementById('report-modal'),
            disconnectedModal: document.getElementById('disconnected-modal'),
            permissionModal: document.getElementById('permission-modal'),
            permissionMessage: document.getElementById('permission-message')
        };
        
        // Initialize Materialize components with error handling
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                // Initialize modals
                M.Modal.init(elements.reportModal, {
                    preventScrolling: true,
                    onCloseEnd: () => {
                        elements.textInput.focus();
                    }
                });
                
                M.Modal.init(elements.disconnectedModal, {
                    preventScrolling: true
                });
                
                M.Modal.init(elements.permissionModal, {
                    preventScrolling: true
                });
                
                // Initialize character counter for text input
                M.CharacterCounter.init(elements.textInput);
                
                // Initialize the app
                await initApp();
                
                // Add service worker for PWA
                if ('serviceWorker' in navigator) {
                    try {
                        await navigator.serviceWorker.register('/sw.js');
                        console.log('Service Worker registered');
                    } catch (error) {
                        console.error('Service Worker registration failed:', error);
                    }
                }
            } catch (error) {
                console.error('Initialization error:', error);
                showError('Failed to initialize the application. Please refresh the page.');
            }
        });
        
        // Main initialization function with enhanced error handling
        async function initApp() {
            console.log('Initializing application...');
            
            try {
                // Initialize Firebase authentication
                await initFirebaseAuth();
                
                // Set up event listeners
                setupEventListeners();
                
                // Check for previous crashes and log
                logAnalyticsEvent('app_loaded', {
                    previous_crash: localStorage.getItem('last_crash') || 'none'
                });
                
                // Clear crash marker
                localStorage.removeItem('last_crash');
                
                console.log('Application initialized successfully');
            } catch (error) {
                console.error('Initialization error:', error);
                localStorage.setItem('last_crash', new Date().toISOString());
                showError('Failed to initialize the application. Please refresh the page.');
                throw error;
            }
        }
        
        // Initialize Firebase authentication with enhanced error handling
        async function initFirebaseAuth() {
            console.log('Initializing Firebase auth...');
            
            try {
                // Sign in anonymously with timeout
                const authPromise = auth.signInAnonymously();
                const timeoutPromise = new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Authentication timeout')), 10000);
                
                await Promise.race([authPromise, timeoutPromise]);
                
                auth.onAuthStateChanged((user) => {
                    if (user) {
                        appState.currentUser = user;
                        console.log('User signed in anonymously with ID:', user.uid);
                        
                        // Set user ID in analytics
                        analytics.setUserId(user.uid);
                    } else {
                        console.log('User is signed out');
                    }
                });
            } catch (error) {
                console.error('Authentication error:', error);
                showError('Failed to connect to chat service. Please check your internet connection.');
                throw error;
            }
        }
        
        // Set up all event listeners with enhanced organization
        function setupEventListeners() {
            console.log('Setting up event listeners...');
            
            // Selection screen events
            elements.videoOption.addEventListener('click', () => selectChatMode('video'));
            elements.videoOption.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') selectChatMode('video');
            });
            
            elements.textOption.addEventListener('click', () => selectChatMode('text'));
            elements.textOption.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') selectChatMode('text');
            });
            
            elements.startBtn.addEventListener('click', startChat);
            
            // Loading screen events
            elements.cancelSearchBtn.addEventListener('click', cancelSearch);
            
            // Video chat events
            elements.videoSkipBtn.addEventListener('click', skipChat);
            elements.videoReportBtn.addEventListener('click', () => openReportModal());
            elements.videoSwitchBtn.addEventListener('click', () => switchChatMode('text'));
            elements.muteAudioBtn.addEventListener('click', toggleAudio);
            elements.muteVideoBtn.addEventListener('click', toggleVideo);
            
            // Text chat events
            elements.textSkipBtn.addEventListener('click', skipChat);
            elements.textReportBtn.addEventListener('click', () => openReportModal());
            elements.textSwitchBtn.addEventListener('click', () => switchChatMode('video'));
            elements.textSendBtn.addEventListener('click', sendTextMessage);
            elements.textInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') sendTextMessage();
            });
            
            // Typing detection
            elements.textInput.addEventListener('input', handleTyping);
            
            // Modal events
            elements.submitReportBtn.addEventListener('click', submitReport);
            elements.findNewBtn.addEventListener('click', findNewPartner);
            elements.retryPermissionBtn.addEventListener('click', retryPermission);
            
            // Handle beforeunload to clean up
            window.addEventListener('beforeunload', cleanupBeforeUnload);
            
            // Handle page visibility changes
            document.addEventListener('visibilitychange', handleVisibilityChange);
            
            // Handle online/offline status
            window.addEventListener('online', handleOnlineStatus);
            window.addEventListener('offline', handleOnlineStatus);
        }
        
        // Select chat mode (video or text) with enhanced UI feedback
        function selectChatMode(mode) {
            console.log('Selected chat mode:', mode);
            appState.chatMode = mode;
            
            // Update UI to show selected mode
            elements.videoOption.classList.toggle('selected', mode === 'video');
            elements.textOption.classList.toggle('selected', mode === 'text');
            
            // Announce selection for accessibility
            const announcement = mode === 'video' ? 
                'Video chat selected. Press start button to begin.' : 
                'Text chat selected. Press start button to begin.';
            announce(announcement);
        }
        
        // Start chat process with enhanced flow
        async function startChat() {
            if (!appState.chatMode) {
                showError('Please select a chat mode first');
                elements.videoOption.focus();
                return;
            }
            
            console.log('Starting', appState.chatMode, 'chat...');
            logAnalyticsEvent('chat_started', { mode: appState.chatMode });
            
            // Show loading screen with animation
            elements.selectionScreen.style.display = 'none';
            elements.loadingScreen.style.display = 'block';
            elements.loadingScreen.classList.add('animate__fadeIn');
            appState.isSearching = true;
            updateStatusMessage('Searching for a partner...');
            
            try {
                // For video chat, get user media first
                if (appState.chatMode === 'video') {
                    await setupLocalMedia();
                }
                
                // Find a chat partner with timeout
                await findChatPartner();
                
                // Show connection quality indicator for video chat
                if (appState.chatMode === 'video') {
                    elements.connectionQuality.style.display = 'flex';
                    monitorConnectionQuality();
                }
            } catch (error) {
                console.error('Error starting chat:', error);
                
                if (error.name === 'NotAllowedError') {
                    showPermissionModal('To use video chat, please allow access to your camera and microphone.');
                } else if (error.name === 'NotFoundError') {
                    showPermissionModal('No camera or microphone found. Please check your devices.');
                } else {
                    showError('Failed to start chat. Please try again.');
                }
                
                cancelSearch();
            }
        }
        
        // Set up local media (video/audio) with enhanced error handling
        async function setupLocalMedia() {
            console.log('Setting up local media...');
            updateStatusMessage('Setting up your camera and microphone...');
            
            try {
                const constraints = {
                    video: {
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                        frameRate: { ideal: 30 }
                    },
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                };
                
                appState.localStream = await navigator.mediaDevices.getUserMedia(constraints);
                
                // Display local video stream
                elements.localVideo.srcObject = appState.localStream;
                
                // Set initial button states
                updateMediaButtons();
                
                console.log('Local media setup complete');
            } catch (error) {
                console.error('Error accessing media devices:', error);
                
                if (error.name === 'NotAllowedError') {
                    throw new Error('Permission denied');
                } else if (error.name === 'NotFoundError') {
                    throw new Error('No devices found');
                } else {
                    throw error;
                }
            }
        }
        
        // Toggle audio mute state
        function toggleAudio() {
            if (!appState.localStream) return;
            
            appState.mediaState.audioEnabled = !appState.mediaState.audioEnabled;
            appState.localStream.getAudioTracks().forEach(track => {
                track.enabled = appState.mediaState.audioEnabled;
            });
            
            updateMediaButtons();
            
            // Log analytics
            logAnalyticsEvent('audio_toggled', {
                state: appState.mediaState.audioEnabled ? 'on' : 'off'
            });
        }
        
        // Toggle video state
        function toggleVideo() {
            if (!appState.localStream) return;
            
            appState.mediaState.videoEnabled = !appState.mediaState.videoEnabled;
            appState.localStream.getVideoTracks().forEach(track => {
                track.enabled = appState.mediaState.videoEnabled;
            });
            
            updateMediaButtons();
            
            // Log analytics
            logAnalyticsEvent('video_toggled', {
                state: appState.mediaState.videoEnabled ? 'on' : 'off'
            });
        }
        
        // Update media control buttons
        function updateMediaButtons() {
            elements.muteAudioBtn.innerHTML = appState.mediaState.audioEnabled ? 
                '<i class="material-icons">mic</i>' : 
                '<i class="material-icons">mic_off</i>';
            elements.muteAudioBtn.classList.toggle('active', !appState.mediaState.audioEnabled);
            
            elements.muteVideoBtn.innerHTML = appState.mediaState.videoEnabled ? 
                '<i class="material-icons">videocam</i>' : 
                '<i class="material-icons">videocam_off</i>';
            elements.muteVideoBtn.classList.toggle('active', !appState.mediaState.videoEnabled);
        }
        
        // Find a chat partner with enhanced matching algorithm
        async function findChatPartner() {
            console.log('Finding chat partner...');
            updateStatusMessage('Finding a suitable partner...');
            
            try {
                // Create a reference to the chat queue collection
                const queueRef = db.collection('chatQueue');
                
                // Check for existing partners waiting in the queue with similar language
                const snapshot = await queueRef
                    .where('mode', '==', appState.chatMode)
                    .where('userId', '!=', appState.currentUser.uid)
                    .orderBy('timestamp', 'asc')
                    .limit(1)
                    .get();
                
                if (!snapshot.empty) {
                    // Found a partner - create a chat room
                    const partnerDoc = snapshot.docs[0];
                    appState.chatPartnerId = partnerDoc.data().userId;
                    
                    console.log('Found partner:', appState.chatPartnerId);
                    updateStatusMessage('Partner found! Connecting...');
                    
                    // Remove partner from queue
                    await partnerDoc.ref.delete();
                    
                    // Create a chat room
                    await createChatRoom(partnerDoc.data().userId);
                } else {
                    // No partner found - add self to queue
                    console.log('No partner found - adding to queue');
                    updateStatusMessage('Waiting for a partner to join...');
                    
                    // Add user preferences to queue (could be expanded with more preferences)
                    await queueRef.add({
                        userId: appState.currentUser.uid,
                        mode: appState.chatMode,
                        language: navigator.language || 'en',
                        timestamp: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    
                    // Listen for a partner to join
                    await listenForPartner();
                }
            } catch (error) {
                console.error('Error finding partner:', error);
                throw error;
            }
        }
        
        // Listen for a partner to join with enhanced timeout handling
        async function listenForPartner() {
            console.log('Listening for partner...');
            
            const queueRef = db.collection('chatQueue');
            let unsubscribe = null;
            let searchTimeout = null;
            
            const cleanupSearch = () => {
                if (unsubscribe) unsubscribe();
                if (searchTimeout) clearTimeout(searchTimeout);
            };
            
            // Set timeout for partner search (3 minutes)
            searchTimeout = setTimeout(async () => {
                if (appState.isSearching) {
                    console.log('Partner search timed out');
                    cleanupSearch();
                    
                    // Remove self from queue
                    const selfQuery = await queueRef
                        .where('userId', '==', appState.currentUser.uid)
                        .limit(1)
                        .get();
                    
                    if (!selfQuery.empty) {
                        await selfQuery.docs[0].ref.delete();
                    }
                    
                    showError('Could not find a partner. Please try again.');
                    cancelSearch();
                }
            }, 3 * 60 * 1000); // 3 minutes
            
            unsubscribe = queueRef
                .where('mode', '==', appState.chatMode)
                .where('userId', '!=', appState.currentUser.uid)
                .orderBy('timestamp', 'asc')
                .limit(1)
                .onSnapshot(async (snapshot) => {
                    if (!snapshot.empty && appState.isSearching) {
                        // Found a partner
                        const partnerDoc = snapshot.docs[0];
                        appState.chatPartnerId = partnerDoc.data().userId;
                        
                        console.log('Partner joined:', appState.chatPartnerId);
                        
                        // Remove self from queue
                        const selfQuery = await queueRef
                            .where('userId', '==', appState.currentUser.uid)
                            .limit(1)
                            .get();
                        
                        if (!selfQuery.empty) {
                            await selfQuery.docs[0].ref.delete();
                        }
                        
                        // Stop listening and timeout
                        cleanupSearch();
                        
                        // Create a chat room
                        await createChatRoom(partnerDoc.data().userId);
                    }
                });
        }
        
        // Create a chat room with enhanced data
        async function createChatRoom(partnerId) {
            console.log('Creating chat room with partner:', partnerId);
            updateStatusMessage('Setting up chat room...');
            
            // Generate a unique room ID
            appState.chatRoomId = generateRoomId(appState.currentUser.uid, partnerId);
            
            // Create room in Firestore
            const roomRef = db.collection('chatRooms').doc(appState.chatRoomId);
            
            try {
                await roomRef.set({
                    user1: appState.currentUser.uid,
                    user2: partnerId,
                    mode: appState.chatMode,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    active: true,
                    user1Info: {
                        userAgent: navigator.userAgent,
                        platform: navigator.platform
                    }
                });
                
                // Set up real-time listeners based on chat mode
                if (appState.chatMode === 'video') {
                    await setupVideoChat(roomRef);
                } else {
                    await setupTextChat(roomRef);
                }
                
                // Hide loading screen and show chat screen with animation
                elements.loadingScreen.style.display = 'none';
                
                if (appState.chatMode === 'video') {
                    elements.videoChatScreen.style.display = 'block';
                    elements.videoChatScreen.classList.add('animate__fadeIn');
                    elements.videoStatus.textContent = 'Connected to partner';
                    elements.remoteVideo.focus();
                } else {
                    elements.textChatScreen.style.display = 'block';
                    elements.textChatScreen.classList.add('animate__fadeIn');
                    elements.textStatus.textContent = 'Connected to partner';
                    elements.textInput.focus();
                }
                
                // Start chat timer
                startChatTimer();
                
                // Log analytics
                logAnalyticsEvent('chat_connected', {
                    mode: appState.chatMode,
                    partnerId: partnerId,
                    roomId: appState.chatRoomId
                });
                
                console.log('Chat room setup complete');
                appState.isSearching = false;
            } catch (error) {
                console.error('Error creating chat room:', error);
                throw error;
            }
        }
        
        // Set up video chat with enhanced WebRTC configuration
        async function setupVideoChat(roomRef) {
            console.log('Setting up video chat...');
            
            // Create peer connection with enhanced configuration
            appState.peerConnection = new RTCPeerConnection(iceServers);
            
            // Add local stream to connection
            appState.localStream.getTracks().forEach(track => {
                appState.peerConnection.addTrack(track, appState.localStream);
            });
            
            // Listen for ICE candidates
            appState.peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log('New ICE candidate:', event.candidate);
                    roomRef.collection('iceCandidates').add({
                        userId: appState.currentUser.uid,
                        candidate: event.candidate,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp()
                    });
                }
            };
            
            // Listen for remote stream
            appState.peerConnection.ontrack = (event) => {
                console.log('Received remote stream');
                elements.remoteVideo.srcObject = event.streams[0];
                
                // Monitor connection quality
                monitorConnectionQuality();
            };
            
            // Listen for connection state changes
            appState.peerConnection.onconnectionstatechange = () => {
                console.log('Connection state:', appState.peerConnection.connectionState);
                updateConnectionStatus(appState.peerConnection.connectionState);
                
                if (appState.peerConnection.connectionState === 'disconnected' || 
                    appState.peerConnection.connectionState === 'failed') {
                    handleDisconnection();
                }
            };
            
            // Listen for ICE connection state changes
            appState.peerConnection.oniceconnectionstatechange = () => {
                console.log('ICE connection state:', appState.peerConnection.iceConnectionState);
                
                // Update connection quality based on ICE state
                switch(appState.peerConnection.iceConnectionState) {
                    case 'connected':
                        appState.connectionQuality = 'good';
                        break;
                    case 'disconnected':
                        appState.connectionQuality = 'fair';
                        break;
                    case 'failed':
                        appState.connectionQuality = 'poor';
                        break;
                }
                
                updateQualityIndicator();
            };
            
            // Create offer if we initiated the chat
            const roomData = (await roomRef.get()).data();
            if (roomData.user1 === appState.currentUser.uid) {
                console.log('Creating offer...');
                
                const offerDescription = await appState.peerConnection.createOffer({
                    offerToReceiveAudio: true,
                    offerToReceiveVideo: true
                });
                
                await appState.peerConnection.setLocalDescription(offerDescription);
                
                await roomRef.update({
                    offer: {
                        type: offerDescription.type,
                        sdp: offerDescription.sdp
                    },
                    from: appState.currentUser.uid
                });
                
                console.log('Offer created and set as local description');
            }
            
            // Listen for answers or offers
            roomRef.onSnapshot(async (snapshot) => {
                const data = snapshot.data();
                
                if (!data) {
                    console.log('Room deleted');
                    handleDisconnection();
                    return;
                }
                
                // If we're user2 and there's an offer, create an answer
                if (data.user2 === appState.currentUser.uid && data.offer && !appState.peerConnection.currentRemoteDescription) {
                    console.log('Received offer, creating answer...');
                    
                    await appState.peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
                    
                    const answerDescription = await appState.peerConnection.createAnswer();
                    await appState.peerConnection.setLocalDescription(answerDescription);
                    
                    await roomRef.update({
                        answer: {
                            type: answerDescription.type,
                            sdp: answerDescription.sdp
                        }
                    });
                    
                    console.log('Answer created and set as local description');
                }
                
                // If we're user1 and there's an answer, set it
                if (data.user1 === appState.currentUser.uid && data.answer && !appState.peerConnection.currentRemoteDescription) {
                    console.log('Received answer, setting remote description...');
                    await appState.peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
                }
            });
            
            // Listen for ICE candidates
            roomRef.collection('iceCandidates')
                .where('userId', '==', appState.chatPartnerId)
                .onSnapshot((snapshot) => {
                    snapshot.docChanges().forEach(async (change) => {
                        if (change.type === 'added') {
                            const candidate = change.doc.data().candidate;
                            console.log('Adding ICE candidate:', candidate);
                            try {
                                await appState.peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                            } catch (error) {
                                console.error('Error adding ICE candidate:', error);
                            }
                        }
                    });
                });
        }
        
        // Monitor WebRTC connection quality
        function monitorConnectionQuality() {
            if (!appState.peerConnection || !appState.peerConnection.getStats) return;
            
            const checkQuality = async () => {
                try {
                    const stats = await appState.peerConnection.getStats();
                    let videoStats = null;
                    
                    stats.forEach(report => {
                        if (report.type === 'inbound-rtp' && report.kind === 'video') {
                            videoStats = report;
                        }
                    });
                    
                    if (videoStats) {
                        // Simple quality assessment based on packet loss
                        const packetLoss = videoStats.packetsLost / videoStats.packetsReceived;
                        
                        if (packetLoss < 0.05) {
                            appState.connectionQuality = 'good';
                        } else if (packetLoss < 0.2) {
                            appState.connectionQuality = 'fair';
                        } else {
                            appState.connectionQuality = 'poor';
                        }
                        
                        updateQualityIndicator();
                    }
                } catch (error) {
                    console.error('Error checking connection quality:', error);
                }
                
                if (appState.chatRoomId) {
                    setTimeout(checkQuality, 5000);
                }
            };
            
            checkQuality();
        }
        
        // Update connection quality indicator
        function updateQualityIndicator() {
            elements.qualityIndicator.className = 'quality-indicator';
            
            switch(appState.connectionQuality) {
                case 'good':
                    elements.qualityIndicator.classList.add('good');
                    break;
                case 'fair':
                    elements.qualityIndicator.classList.add('fair');
                    break;
                case 'poor':
                    elements.qualityIndicator.classList.add('poor');
                    break;
            }
        }
        
        // Update connection status display
        function updateConnectionStatus(status) {
            const statusText = {
                'new': 'Connecting...',
                'connecting': 'Connecting...',
                'connected': 'Connected',
                'disconnected': 'Disconnected',
                'failed': 'Connection Failed',
                'closed': 'Connection Closed'
            };
            
            if (appState.chatMode === 'video') {
                elements.videoStatus.textContent = statusText[status] || status;
            } else {
                elements.textStatus.textContent = statusText[status] || status;
            }
        }
        
        // Set up text chat with typing indicators
        async function setupTextChat(roomRef) {
            console.log('Setting up text chat...');
            
            // Clear previous messages
            elements.textMessages.innerHTML = '';
            
            // Listen for new messages
            roomRef.collection('messages')
                .orderBy('timestamp', 'asc')
                .onSnapshot((snapshot) => {
                    snapshot.docChanges().forEach((change) => {
                        if (change.type === 'added') {
                            const message = change.doc.data();
                            displayMessage(message);
                        }
                    });
                    
                    // Hide empty state if messages exist
                    if (!snapshot.empty) {
                        const emptyState = elements.textMessages.querySelector('.empty-state');
                        if (emptyState) emptyState.remove();
                    }
                });
            
            // Listen for typing indicators
            roomRef.onSnapshot((snapshot) => {
                const data = snapshot.data();
                if (!data) return;
                
                // Check if partner is typing
                const isTyping = data.partnerTyping === appState.currentUser.uid;
                
                if (isTyping !== appState.partnerTyping) {
                    appState.partnerTyping = isTyping;
                    updateTypingIndicator();
                }
            });
            
            // Listen for room changes (partner disconnection)
            roomRef.onSnapshot((snapshot) => {
                const data = snapshot.data();
                if (!data || !data.active) {
                    handleDisconnection();
                }
            });
        }
        
        // Handle typing detection
        function handleTyping() {
            if (!appState.chatRoomId) return;
            
            // Clear previous timeout
            if (appState.typingTimeout) clearTimeout(appState.typingTimeout);
            
            // Set typing state
            if (!appState.isTyping) {
                appState.isTyping = true;
                updatePartnerTypingStatus(true);
            }
            
            // Set timeout to clear typing state after 3 seconds of inactivity
            appState.typingTimeout = setTimeout(() => {
                appState.isTyping = false;
                updatePartnerTypingStatus(false);
            }, 3000);
        }
        
        // Update partner's typing status in Firestore
        function updatePartnerTypingStatus(isTyping) {
            if (!appState.chatRoomId) return;
            
            const update = isTyping ? 
                { partnerTyping: appState.currentUser.uid } : 
                { partnerTyping: firebase.firestore.FieldValue.delete() };
            
            db.collection('chatRooms').doc(appState.chatRoomId).update(update)
                .catch(error => {
                    console.error('Error updating typing status:', error);
                });
        }
        
        // Update typing indicator UI
        function updateTypingIndicator() {
            if (appState.chatMode === 'video') {
                elements.videoTypingIndicator.classList.toggle('active', appState.partnerTyping);
            } else {
                elements.textTypingIndicator.classList.toggle('active', appState.partnerTyping);
            }
        }
        
        // Display a text message with enhanced formatting
        function displayMessage(message) {
            // Remove empty state if it exists
            const emptyState = elements.textMessages.querySelector('.empty-state');
            if (emptyState && elements.textMessages.children.length === 1) {
                emptyState.remove();
            }
            
            const messageElement = document.createElement('div');
            messageElement.classList.add('message');
            
            if (message.userId === appState.currentUser.uid) {
                messageElement.classList.add('sent');
            } else {
                messageElement.classList.add('received');
            }
            
            // Format message text with link detection and emoji support
            let messageText = escapeHtml(message.text);
            
            // Enhanced link detection with URL preview avoidance
            const urlRegex = /(https?:\/\/[^\s]+)/g;
            messageText = messageText.replace(urlRegex, (url) => {
                // Truncate long URLs
                const displayUrl = url.length > 30 ? url.substring(0, 27) + '...' : url;
                return `<a href="${url}" target="_blank" rel="noopener noreferrer nofollow">${displayUrl}</a>`;
            });
            
            // Add timestamp
            const timestamp = message.timestamp ? 
                formatTimestamp(message.timestamp.toDate()) : 
                'Just now';
            
            messageElement.innerHTML = `${messageText}<span class="message-time">${timestamp}</span>`;
            
            // Add animation for new messages
            messageElement.classList.add('new-message');
            
            elements.textMessages.appendChild(messageElement);
            
            // Scroll to bottom with smooth behavior
            elements.textMessages.scrollTo({
                top: elements.textMessages.scrollHeight,
                behavior: 'smooth'
            });
        }
        
        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Format timestamp for display
        function formatTimestamp(date) {
            const now = new Date();
            const diff = now - date;
            
            if (diff < 60000) { // Less than 1 minute
                return 'Just now';
            } else if (diff < 3600000) { // Less than 1 hour
                const minutes = Math.floor(diff / 60000);
                return `${minutes} min ago`;
            } else if (diff < 86400000) { // Less than 1 day
                return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            } else {
                return date.toLocaleDateString([], { month: 'short', day: 'numeric' });
            }
        }
        
        // Send a text message with enhanced validation
        async function sendTextMessage() {
            const messageText = elements.textInput.value.trim();
            
            if (!messageText) {
                elements.textInput.focus();
                return;
            }
            
            // Check for offensive words
            if (containsOffensiveWords(messageText)) {
                showError('Your message contains inappropriate content. Please modify it.');
                elements.textInput.focus();
                return;
            }
            
            // Check for excessive length
            if (messageText.length > 500) {
                showError('Message is too long. Please keep it under 500 characters.');
                elements.textInput.focus();
                return;
            }
            
            // Disable send button during send
            elements.textSendBtn.disabled = true;
            
            try {
                await db.collection('chatRooms').doc(appState.chatRoomId).collection('messages').add({
                    userId: appState.currentUser.uid,
                    text: messageText,
                    timestamp: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Clear input and reset typing state
                elements.textInput.value = '';
                if (appState.typingTimeout) clearTimeout(appState.typingTimeout);
                if (appState.isTyping) {
                    appState.isTyping = false;
                    updatePartnerTypingStatus(false);
                }
                
                // Log analytics
                logAnalyticsEvent('message_sent', {
                    length: messageText.length,
                    containsLinks: messageText.includes('http')
                });
            } catch (error) {
                console.error('Error sending message:', error);
                showError('Failed to send message. Please try again.');
            } finally {
                elements.textSendBtn.disabled = false;
                elements.textInput.focus();
            }
        }
        
        // Check for offensive words with enhanced matching
        function containsOffensiveWords(text) {
            const lowerText = text.toLowerCase();
            
            // Check for exact matches
            if (offensiveWords.some(word => {
                const regex = new RegExp(`\\b${word}\\b`, 'i');
                return regex.test(text);
            })) {
                return true;
            }
            
            // Check for common evasions (leetspeak, etc.)
            const evasionPatterns = [
                /f[u*]ck/i,
                /s[h*]it/i,
                /a[s*]s/i,
                /b[i*]tch/i,
                /n[i*]gg/i
            ];
            
            return evasionPatterns.some(pattern => pattern.test(text));
        }
        
        // Start chat timer with enhanced display
        function startChatTimer() {
            appState.chatStartTime = new Date();
            
            appState.timerInterval = setInterval(() => {
                const now = new Date();
                const elapsed = Math.floor((now - appState.chatStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
                const seconds = (elapsed % 60).toString().padStart(2, '0');
                
                if (appState.chatMode === 'video') {
                    elements.videoTimer.textContent = `${minutes}:${seconds}`;
                } else {
                    elements.textTimer.textContent = `${minutes}:${seconds}`;
                }
            }, 1000);
        }
        
        // Skip current chat with confirmation
        async function skipChat() {
            // Show confirmation dialog for the first skip
            const skipConfirmed = await showConfirmation(
                'Skip this chat?',
                'Are you sure you want to skip this chat partner?',
                'Skip',
                'Cancel'
            );
            
            if (!skipConfirmed) return;
            
            console.log('Skipping chat...');
            logAnalyticsEvent('chat_skipped', {
                mode: appState.chatMode,
                duration: getChatDuration()
            });
            
            await endCurrentChat();
            await startNewSearch();
        }
        
        // Show confirmation dialog
        function showConfirmation(title, message, confirmText, cancelText) {
            return new Promise((resolve) => {
                M.Modal.init(document.createElement('div')); // Initialize modal plugin
                
                const modal = M.Modal.getInstance(
                    M.Modal.init(document.createElement('div'), {
                        title,
                        message,
                        buttons: [
                            {
                                text: cancelText,
                                class: 'btn-outline',
                                handler: () => resolve(false)
                            },
                            {
                                text: confirmText,
                                class: 'btn-primary',
                                handler: () => resolve(true)
                            }
                        ]
                    })
                );
                
                modal.open();
            });
        }
        
        // Switch chat mode with enhanced transition
        async function switchChatMode(newMode) {
            console.log('Switching to', newMode, 'mode...');
            logAnalyticsEvent('mode_switched', {
                from: appState.chatMode,
                to: newMode,
                duration: getChatDuration()
            });
            
            await endCurrentChat();
            appState.chatMode = newMode;
            await startChat();
        }
        
        // End current chat with proper cleanup
        async function endCurrentChat() {
            console.log('Ending current chat...');
            
            // Clear timer
            if (appState.timerInterval) {
                clearInterval(appState.timerInterval);
                appState.timerInterval = null;
            }
            
            // Close peer connection if video chat
            if (appState.peerConnection) {
                appState.peerConnection.close();
                appState.peerConnection = null;
            }
            
            // Stop local media tracks
            if (appState.localStream) {
                appState.localStream.getTracks().forEach(track => track.stop());
                appState.localStream = null;
            }
            
            // Update room status in Firestore
            if (appState.chatRoomId) {
                try {
                    await db.collection('chatRooms').doc(appState.chatRoomId).update({
                        active: false,
                        endedAt: firebase.firestore.FieldValue.serverTimestamp(),
                        endedBy: appState.currentUser.uid
                    });
                } catch (error) {
                    console.error('Error updating room status:', error);
                }
            }
            
            // Hide chat screens with animation
            if (appState.chatMode === 'video') {
                elements.videoChatScreen.classList.add('animate__fadeOut');
                setTimeout(() => {
                    elements.videoChatScreen.style.display = 'none';
                    elements.videoChatScreen.classList.remove('animate__fadeOut');
                }, 300);
            } else {
                elements.textChatScreen.classList.add('animate__fadeOut');
                setTimeout(() => {
                    elements.textChatScreen.style.display = 'none';
                    elements.textChatScreen.classList.remove('animate__fadeOut');
                }, 300);
            }
            
            // Reset variables
            appState.chatRoomId = null;
            appState.chatPartnerId = null;
            appState.partnerTyping = false;
            updateTypingIndicator();
        }
        
        // Start new search with smooth transition
        async function startNewSearch() {
            elements.loadingScreen.style.display = 'block';
            elements.loadingScreen.classList.add('animate__fadeIn');
            appState.isSearching = true;
            updateStatusMessage('Searching for a new partner...');
            
            try {
                await findChatPartner();
            } catch (error) {
                console.error('Error starting new search:', error);
                showError('Failed to find a new partner. Please try again.');
                cancelSearch();
            }
        }
        
        // Find new partner after disconnection
        async function findNewPartner() {
            M.Modal.getInstance(elements.disconnectedModal).close();
            await startNewSearch();
        }
        
        // Cancel search and return to selection screen
        function cancelSearch() {
            console.log('Cancelling search...');
            
            // Reset state
            appState.isSearching = false;
            
            // Stop local media if video chat
            if (appState.localStream) {
                appState.localStream.getTracks().forEach(track => track.stop());
                appState.localStream = null;
            }
            
            // Remove from queue if still searching
            if (appState.currentUser) {
                db.collection('chatQueue')
                    .where('userId', '==', appState.currentUser.uid)
                    .get()
                    .then((snapshot) => {
                        snapshot.forEach(doc => doc.ref.delete());
                    });
            }
            
            // Show selection screen with animation
            elements.loadingScreen.classList.add('animate__fadeOut');
            setTimeout(() => {
                elements.loadingScreen.style.display = 'none';
                elements.loadingScreen.classList.remove('animate__fadeOut');
                elements.selectionScreen.style.display = 'block';
                elements.selectionScreen.classList.add('animate__fadeIn');
            }, 300);
        }
        
        // Handle disconnection with proper cleanup
        function handleDisconnection() {
            console.log('Partner disconnected');
            
            // Clear timer
            if (appState.timerInterval) {
                clearInterval(appState.timerInterval);
                appState.timerInterval = null;
            }
            
            // Close peer connection if video chat
            if (appState.peerConnection) {
                appState.peerConnection.close();
                appState.peerConnection = null;
            }
            
            // Stop local media tracks
            if (appState.localStream) {
                appState.localStream.getTracks().forEach(track => track.stop());
                appState.localStream = null;
            }
            
            // Hide chat screens
            elements.videoChatScreen.style.display = 'none';
            elements.textChatScreen.style.display = 'none';
            
            // Show disconnection modal
            M.Modal.getInstance(elements.disconnectedModal).open();
            
            // Log analytics
            logAnalyticsEvent('chat_disconnected', {
                mode: appState.chatMode,
                duration: getChatDuration()
            });
            
            // Reset variables
            appState.chatRoomId = null;
            appState.chatPartnerId = null;
            appState.partnerTyping = false;
            updateTypingIndicator();
        }
        
        // Show permission modal
        function showPermissionModal(message) {
            elements.permissionMessage.textContent = message;
            M.Modal.getInstance(elements.permissionModal).open();
        }
        
        // Retry permission request
        async function retryPermission() {
            M.Modal.getInstance(elements.permissionModal).close();
            await startChat();
        }
        
        // Open report modal with enhanced options
        function openReportModal() {
            // Reset form
            document.querySelector('input[name="report-reason"][value="spam"]').checked = true;
            document.getElementById('report-notes').value = '';
            
            M.Modal.getInstance(elements.reportModal).open();
        }
        
        // Submit report with enhanced data
        async function submitReport() {
            const reason = document.querySelector('input[name="report-reason"]:checked').value;
            const notes = document.getElementById('report-notes').value;
            
            console.log('Submitting report for partner:', appState.chatPartnerId);
            
            try {
                await db.collection('reports').add({
                    reporterId: appState.currentUser.uid,
                    reportedId: appState.chatPartnerId,
                    roomId: appState.chatRoomId,
                    reason: reason,
                    notes: notes,
                    timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                    mode: appState.chatMode,
                    duration: getChatDuration(),
                    reporterInfo: {
                        userAgent: navigator.userAgent,
                        platform: navigator.platform
                    }
                });
                
                showSuccess('Thank you for your report. We will review it shortly.');
                M.Modal.getInstance(elements.reportModal).close();
                
                // Log analytics
                logAnalyticsEvent('user_reported', {
                    reason: reason,
                    mode: appState.chatMode
                });
                
                // Skip after reporting
                await skipChat();
            } catch (error) {
                console.error('Error submitting report:', error);
                showError('Failed to submit report. Please try again.');
            }
        }
        
        // Clean up before page unload
        function cleanupBeforeUnload() {
            console.log('Cleaning up before unload...');
            
            // End current chat if active
            if (appState.chatRoomId) {
                db.collection('chatRooms').doc(appState.chatRoomId).update({
                    active: false,
                    endedAt: firebase.firestore.FieldValue.serverTimestamp(),
                    endedBy: appState.currentUser.uid
                });
            }
            
            // Remove from queue if searching
            if (appState.isSearching && appState.currentUser) {
                db.collection('chatQueue')
                    .where('userId', '==', appState.currentUser.uid)
                    .get()
                    .then((snapshot) => {
                        snapshot.forEach(doc => doc.ref.delete());
                    });
            }
            
            // Close peer connection if video chat
            if (appState.peerConnection) {
                appState.peerConnection.close();
            }
            
            // Stop local media tracks
            if (appState.localStream) {
                appState.localStream.getTracks().forEach(track => track.stop());
            }
        }
        
        // Handle page visibility changes
        function handleVisibilityChange() {
            if (document.hidden) {
                // Page is hidden, log inactive time
                logAnalyticsEvent('app_backgrounded', {
                    mode: appState.chatMode,
                    duration: getChatDuration()
                });
            } else {
                // Page is visible again
                logAnalyticsEvent('app_foregrounded', {
                    mode: appState.chatMode,
                    duration: getChatDuration()
                });
            }
        }
        
        // Handle online/offline status
        function handleOnlineStatus() {
            if (navigator.onLine) {
                updateStatusMessage('Reconnected. Searching for partner...');
                logAnalyticsEvent('connection_restored');
            } else {
                updateStatusMessage('Connection lost. Trying to reconnect...');
                logAnalyticsEvent('connection_lost');
            }
        }
        
        // Update status message with typing indicator
        function updateStatusMessage(message) {
            elements.statusMessage.textContent = message;
            elements.statusMessage.setAttribute('aria-live', 'polite');
        }
        
        // Show error message with enhanced UI
        function showError(message) {
            M.toast({
                html: `<i class="material-icons left">error</i> ${message}`,
                classes: 'red darken-2',
                displayLength: 4000
            });
        }
        
        // Show success message
        function showSuccess(message) {
            M.toast({
                html: `<i class="material-icons left">check_circle</i> ${message}`,
                classes: 'green darken-2',
                displayLength: 4000
            });
        }
        
        // Announce message for screen readers
        function announce(message) {
            const announcement = document.createElement('div');
            announcement.setAttribute('aria-live', 'polite');
            announcement.style.position = 'absolute';
            announcement.style.left = '-9999px';
            announcement.textContent = message;
            document.body.appendChild(announcement);
            
            setTimeout(() => {
                document.body.removeChild(announcement);
            }, 1000);
        }
        
        // Log analytics event with enhanced error handling
        function logAnalyticsEvent(eventName, eventParams = {}) {
            try {
                // Add common parameters
                const enhancedParams = {
                    ...eventParams,
                    chatMode: appState.chatMode,
                    timestamp: new Date().toISOString()
                };
                
                analytics.logEvent(eventName, enhancedParams);
                console.log('Logged analytics event:', eventName, enhancedParams);
            } catch (error) {
                console.error('Error logging analytics event:', error);
            }
        }
        
        // Generate room ID from user IDs
        function generateRoomId(userId1, userId2) {
            const sortedIds = [userId1, userId2].sort();
            return sortedIds.join('_') + '_' + Date.now();
        }
        
        // Get chat duration in seconds
        function getChatDuration() {
            if (!appState.chatStartTime) return 0;
            return Math.floor((new Date() - appState.chatStartTime) / 1000);
        }
  
        // Initialize the app when DOM is fully loaded
        document.addEventListener('DOMContentLoaded', () => {
            // Set default chat mode to video for better user experience
            selectChatMode('video');
            
            // Focus on the video option for accessibility
            elements.videoOption.focus();
            
            // Add hover effects to chat options
            setupHoverEffects();
            
            // Check for PWA installation prompt
            checkPWAInstallPrompt();
        });

        // Setup hover effects for chat options
        function setupHoverEffects() {
            const options = [elements.videoOption, elements.textOption];
            
            options.forEach(option => {
                option.addEventListener('mouseenter', () => {
                    if (!option.classList.contains('selected')) {
                        option.style.transform = 'translateY(-5px)';
                        option.style.boxShadow = '0 5px 15px rgba(0,0,0,0.1)';
                    }
                });
                
                option.addEventListener('mouseleave', () => {
                    if (!option.classList.contains('selected')) {
                        option.style.transform = '';
                        option.style.boxShadow = '';
                    }
                });
            });
        }

        // Check for PWA installation prompt
        function checkPWAInstallPrompt() {
            let deferredPrompt;
            
            window.addEventListener('beforeinstallprompt', (e) => {
                // Prevent the mini-infobar from appearing on mobile
                e.preventDefault();
                // Stash the event so it can be triggered later
                deferredPrompt = e;
                
                // Show custom install button (could be added to UI)
                showPWAInstallButton();
            });
            
            window.addEventListener('appinstalled', () => {
                // Log installation to analytics
                logAnalyticsEvent('pwa_installed');
                // Hide the install button
                hidePWAInstallButton();
            });
        }

        // Show PWA install button
        function showPWAInstallButton() {
            // In a real implementation, you would show a button in your UI
            console.log('PWA installation available');
        }

        // Hide PWA install button
        function hidePWAInstallButton() {
            // In a real implementation, you would hide the button
            console.log('PWA installed');
        }

        // Additional utility function to detect mobile devices
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        // Enhanced error handling for media devices
        function handleMediaError(error) {
            console.error('Media error:', error);
            
            switch(error.name) {
                case 'NotAllowedError':
                    showPermissionModal('Please allow camera and microphone access to use video chat.');
                    break;
                case 'NotFoundError':
                    showPermissionModal('No camera or microphone found. Please check your devices.');
                    break;
                case 'NotReadableError':
                    showPermissionModal('Camera or microphone is already in use by another application.');
                    break;
                case 'OverconstrainedError':
                    showPermissionModal('Your device doesn\'t meet the requirements for video chat.');
                    break;
                default:
                    showError('Failed to access camera or microphone. Please try again.');
            }
        }

        // Enhanced function to check camera and microphone permissions
        async function checkMediaPermissions() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const hasCamera = devices.some(device => device.kind === 'videoinput');
                const hasMicrophone = devices.some(device => device.kind === 'audioinput');
                
                if (!hasCamera || !hasMicrophone) {
                    throw new Error('Required devices not found');
                }
                
                return true;
            } catch (error) {
                console.error('Permission check error:', error);
                return false;
            }
        }

        // Function to handle browser compatibility checks
        function checkBrowserCompatibility() {
            const supported = {
                webrtc: !!window.RTCPeerConnection,
                firestore: !!firebase.firestore,
                indexedDB: !!window.indexedDB,
                serviceWorker: 'serviceWorker' in navigator
            };
            
            if (!supported.webrtc || !supported.firestore) {
                showError('Your browser doesn\'t support all required features. Please try Chrome, Firefox, or Edge.');
                return false;
            }
            
            return true;
        }

        // Function to estimate bandwidth
        async function estimateBandwidth() {
            if (!navigator.connection || !navigator.connection.effectiveType) {
                return 'unknown';
            }
            
            const connection = navigator.connection;
            const effectiveType = connection.effectiveType;
            
            // Add more sophisticated estimation if needed
            return effectiveType;
        }

        // Function to handle orientation changes
        function handleOrientationChange() {
            if (window.matchMedia('(orientation: portrait)').matches) {
                // Portrait mode
                if (appState.chatMode === 'video' && elements.localVideo) {
                    elements.localVideo.style.width = '40%';
                }
            } else {
                // Landscape mode
                if (appState.chatMode === 'video' && elements.localVideo) {
                    elements.localVideo.style.width = '25%';
                }
            }
        }

        // Add orientation change listener
        window.addEventListener('orientationchange', handleOrientationChange);

        // Initialize orientation handling
        handleOrientationChange();

        // Final initialization checks
        if (!checkBrowserCompatibility()) {
            document.getElementById('start-btn').disabled = true;
        }

        // Export functions for testing if needed
        if (typeof module !== 'undefined' && module.exports) {
            module.exports = {
                selectChatMode,
                startChat,
                sendTextMessage,
                containsOffensiveWords,
                getChatDuration,
                isMobileDevice,
                checkMediaPermissions
            };
        }
        // Add performance monitoring
        const startTime = performance.now();
        window.addEventListener('load', () => {
            const loadTime = performance.now() - startTime;
            logAnalyticsEvent('page_load', {
                load_time: Math.round(loadTime),
                device_type: isMobileDevice() ? 'mobile' : 'desktop'
            });
        });

        // Add network status monitoring
        function monitorNetworkStatus() {
            if ('connection' in navigator) {
                navigator.connection.addEventListener('change', () => {
                    logAnalyticsEvent('network_change', {
                        effectiveType: navigator.connection.effectiveType,
                        downlink: navigator.connection.downlink,
                        rtt: navigator.connection.rtt
                    });
                    
                    // Update UI if in video chat
                    if (appState.chatMode === 'video' && appState.chatRoomId) {
                        updateConnectionStatus(navigator.connection.effectiveType);
                    }
                });
            }
        }

        // Initialize network monitoring
        monitorNetworkStatus();

        // Add battery status monitoring (where supported)
        function monitorBatteryStatus() {
            if ('getBattery' in navigator) {
                navigator.getBattery().then(battery => {
                    battery.addEventListener('levelchange', () => {
                        if (battery.level < 0.2 && !appState.lowBatteryWarningShown) {
                            showError('Low battery! Consider plugging in your device for best performance.');
                            appState.lowBatteryWarningShown = true;
                            logAnalyticsEvent('low_battery_warning');
                        }
                    });
                });
            }
        }

        // Initialize battery monitoring
        monitorBatteryStatus();

        // Add memory monitoring (where supported)
        function monitorMemory() {
            if ('deviceMemory' in navigator) {
                logAnalyticsEvent('device_memory', {
                    memory: navigator.deviceMemory
                });
                
                if (navigator.deviceMemory < 2) {
                    console.log('Low memory device detected, enabling performance optimizations');
                    // Could implement performance optimizations here
                }
            }
        }

        // Initialize memory monitoring
        monitorMemory();

        // Add error tracking
        window.addEventListener('error', (event) => {
            logAnalyticsEvent('runtime_error', {
                message: event.message,
                filename: event.filename,
                lineno: event.lineno,
                colno: event.colno,
                stack: event.error?.stack
            });
        });

        // Add unhandled promise rejection tracking
        window.addEventListener('unhandledrejection', (event) => {
            logAnalyticsEvent('unhandled_rejection', {
                reason: event.reason?.message || String(event.reason)
            });
        });

        // Add session duration tracking
        let sessionStart = new Date();
        setInterval(() => {
            const sessionDuration = Math.floor((new Date() - sessionStart) / 1000);
            if (sessionDuration % 30 === 0) { // Log every 30 seconds
                logAnalyticsEvent('session_heartbeat', {
                    duration: sessionDuration,
                    active_chat: !!appState.chatRoomId,
                    chat_mode: appState.chatMode
                });
            }
        }, 30000);

        // Add visibility change tracking
        document.addEventListener('visibilitychange', () => {
            logAnalyticsEvent('visibility_change', {
                visible: !document.hidden,
                chat_active: !!appState.chatRoomId
            });
        });

        // Add beforeunload handler to clean up resources
        window.addEventListener('beforeunload', (event) => {
            if (appState.chatRoomId) {
                // Only warn if in an active chat
                event.preventDefault();
                event.returnValue = 'You are currently in a chat. Are you sure you want to leave?';
                return event.returnValue;
            }
        });

        // Add service worker update detection
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/sw.js').then(registration => {
                registration.addEventListener('updatefound', () => {
                    logAnalyticsEvent('service_worker_update');
                    showSuccess('A new version is available. Please refresh the page.');
                });
            });
        }

        // Add language detection
        const userLanguage = navigator.language || 'en-US';
        logAnalyticsEvent('language_detected', {
            language: userLanguage.split('-')[0],
            region: userLanguage.split('-')[1] || 'none'
        });

        // Add dark mode preference detection
        const darkModePreference = window.matchMedia('(prefers-color-scheme: dark)').matches;
        logAnalyticsEvent('color_scheme', {
            dark_mode: darkModePreference
        });

        // Add final initialization log
        logAnalyticsEvent('app_initialized', {
            user_agent: navigator.userAgent,
            platform: navigator.platform,
            cores: navigator.hardwareConcurrency || 'unknown'
        });

        // Export additional functions for testing
        if (typeof module !== 'undefined' && module.exports) {
            module.exports = {
                ...module.exports, // Keep previous exports
                monitorNetworkStatus,
                monitorBatteryStatus,
                monitorMemory,
                handleMediaError,
                estimateBandwidth,
                handleOrientationChange
            };
        }
    </script>
</body>
</html>